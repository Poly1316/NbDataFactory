#coding=utf-8
#author: chenfei
#2018-4-21 14:50:47
#
from eyetoollib.common import toString
import psutil
import sys
import time
import os

class InfoCollection(object):
    '''
    基础信息收集
    '''
    def get_users(self):
        '''
        连接用户列表
        name: 用户名
        terminal: 终端
        host: 主机
        started: 开始时间
        pid: 用户进程号
        '''
        rs = []
        users = psutil.users() 
        for user in users:
            rs.append({
                'name': user.name,
                'terminal': user.terminal,
                'host': user.host,
                'started': user.started,
                'pid': user.pid
                })
        return rs

    def get_boot_time(self):
        '''
        系统开机时间
        boot_time: 系统开机时间
        running_period: 系统运行时间
        '''
        rs              = {}
        boot_time       = psutil.boot_time()
        period          = int(time.time() - boot_time)
        running_period  = ''
        if period < 3600:
            running_period = '< 1小时'
        elif period > 3600 and period < 3600 * 24:
            running_period = '{}小时'.format(period/3600)
        else:
            running_period = '{}天{}小时'.format(period/(3600*24), 
                                                (period % (3600*24))/3600)
        rs['boot_time']         = boot_time
        rs['running_period']    = running_period
        return rs

    def get_cpu_count(self):
        '''
        获取CPU核心数
        cpu_count_logical: 系统逻辑CPU核心数
        cpu_count: 系统物理CPU核心数
        '''
        return {
            'cpu_count_logical': psutil.cpu_count(),
            'cpu_count': psutil.cpu_count(logical=False)
        }

    def get_cpu_times(self):
        '''
        获取CPU各指标时间  所有属性的单位都为：秒
        user 正常进程在用户模式下执行花费的时间； 在Linux上包括了访客时间(guest)
        system 内核模式下进程执行花费的时间
        idle 空闲时间

        Linux:

        nice  在用户模式下优先化进程执行花费的时间，在Linux上包含guest_nice时间
        iowait 等待I/O完成的时间 
        irq 花费在服务于硬件中断上的时间 
        softirq 花费在服务于软件中断上的时间
        steal Linux2.6.11+ 在虚拟环境中运行其他操作系统所花费的时间
        guest Linux2.6.24+ 花费在Linux内核控制下为客户操作系统运行虚拟CPU的时间
        guest_nice Linux3.2.0+ 

        Windows:

        interrupt 和irq意思一样
        dpc 花费在服务延期程序调用上的时间 是一个列表，第一个值表示第一个CPU 以此类推
        '''
        times = psutil.cpu_times(percpu=False)
        rs = {
            'user': times.user, # 正常进程在用户模式下执行花费的时间； 在Linux上包括了访客时间(guest)
            'system': times.system, # 内核模式下进程执行花费的时间
            'idle': times.idle,  # 空闲时间
        }
        if sys.platform.startswith('linux'):
            rs.update({
                'nice': times.nice, # Unix 在用户模式下优先化进程执行花费的时间，在Linux上包含guest_nice时间
                'iowait': times.iowait, # Linux 等待I/O完成的时间 
                'irq': times.irq, # Linux 花费在服务于硬件中断上的时间 
                'softirq': times.softirq, # Linux 花费在服务于软件中断上的时间
                'steal': times.steal, # Linux2.6.11+ 在虚拟环境中运行其他操作系统所花费的时间
                'guest': times.guest, # Linux2.6.24+ 花费在Linux内核控制下为客户操作系统运行虚拟CPU的时间
                # 'guest_nice': times.guest_nice, # Linux3.2.0+ 
                })
        elif sys.platform == 'win32':
            rs.update({
                'interrupt': times.interrupt, # Windows 和irq意思一样
                'dpc': times.dpc # Windows 花费在服务延期程序调用上的时间 是一个列表，第一个值表示第一个CPU 以此类推
                })
        return rs

    def get_cpu_stats(self):
        '''
        CPU统计信息
        ctx_switches 自启动以来的上下文切换次数(自愿 + 非自愿)
        interrupts  自启动以来的中断次数
        soft_interrupts 自启动以来的软件中断次数 windows和sunos始终为0
        syscalls 自启动以来的系统调用次数 Linux上始终为0
        '''
        stats = psutil.cpu_stats()
        return {
            'ctx_switches': stats.ctx_switches, # 自启动以来的上下文切换次数(自愿 + 非自愿)
            'interrupts': stats.interrupts, # 自启动以来的中断次数
            'soft_interrupts': stats.soft_interrupts, # 自启动以来的软件中断次数 windows和sunos始终为0
            'syscalls': stats.syscalls, # 自启动以来的系统调用次数 Linux上始终为0
        }

    def get_cpu_percent(self, interval=1, percpu=False):
        '''
        CPU利用率百分比 
        interval 间隔最好大于0.1秒
        percpu True的话返回的是一个list 一次对应每个cpu
        '''
        return {
            'cpu_percent': psutil.cpu_percent(interval=interval, percpu=percpu)
        }

    def get_cpu_times_percent(self, interval=1, percpu=False):
        '''
        CPU各指标时间的百分比  单位是百分比，各个指标含义参考 get_cpu_times()
        '''
        times = psutil.cpu_times_percent(interval=interval, percpu=False)
        rs = {
            'user': times.user, # 正常进程在用户模式下执行花费的时间； 在Linux上包括了访客时间(guest)
            'system': times.system, # 内核模式下进程执行花费的时间
            'idle': times.idle,  # 空闲时间
        }
        if sys.platform.startswith('linux'):
            rs.update({
                'nice': times.nice, 
                'iowait': times.iowait, 
                'irq': times.irq, 
                'softirq': times.softirq,
                'steal': times.steal, 
                'guest': times.guest, 
                # 'guest_nice': times.guest_nice,
                })
        elif sys.platform == 'win32':
            rs.update({
                'interrupt': times.interrupt, 
                'dpc': times.dpc 
                })
        return rs

    def get_virtual_memory(self):
        '''
        系统内存使用情况  单位是bytes 字节

        total != used + available
        windows系统中，available == free
        如果只是想知道跨平台方式下还剩下多少物理内存，可以直接参考available字段，如：
        threshold = 100 * 1024 * 1024 # 100MB
        mem = psutil.virtual_memory()
        if mem.available <= threshold:
            print('warning')

        字段解释：

        total 内存总量
        available: 可用内存，注意： 可用内存不等于空闲内存
        used: 已使用的内存（根据平台差异性计算） 注意： used != total-free
        free: 空闲内存 注意： free != total-used
        
        active: UNIX 正在使用或最近使用的内存，it is in RAM
        inactive: UNIX 被标记为未使用的内存
        buffers: Linux 文件系统元数据等内容的缓存
        cached: Linux 各种内容的缓存
        shared: Linux 共享内存
        slab: Linux 内核内数据结构缓存
        '''
        mem = psutil.virtual_memory()
        rs = {
            'total': mem.total,
            'available': mem.available,
            'used': mem.used,
            'free': mem.free,
            'percent': '%.2f%%' % (float(mem.total - mem.available) / float(mem.total) * 100) # 内存使用百分比
        }
        if sys.platform.startswith('linux'):
            rs.update({
                'active': mem.active,
                'inactive': mem.inactive,
                'buffers': mem.buffers,
                'cached': mem.cached,
                'shared': mem.shared,
                #'slab': mem.slab
                })
            try:
                rs.update({
                    'slab': mem.slab
                    })
            except:
                pass
        return rs

    def get_swap_memory(self):
        '''
        系统交换内存
        total:  total swap memory in bytes
        used: used swap memory in bytes
        free: free swap memory in bytes
        percent:  使用百分比，计算公式： (total - available) / total * 100
        sin: 系统从磁盘交换的字节数（累计）swap in
        sout: 系统从磁盘交换出的字节数（累计）swap out

        Windows中sin和sout始终为0
        '''
        sm = psutil.swap_memory()
        return {
            'total': sm.total,
            'used': sm.used,
            'free': sm.free,
            'percent': sm.percent,
            'sin': sm.sin,
            'sout': sm.sout
        }

    def get_disk_partitions(self, all=False):
        '''
        磁盘分区 (mounted disk) like 'df' command
        all=False的时候，将尝试区分和返回物理设备并忽略所有其他设备
        '''
        rs = []
        dps = psutil.disk_partitions(all=all)
        for dp in dps:
            rs.append({
                'device': dp.device,
                'mountpoint': dp.mountpoint,
                'fstype': dp.fstype,
                'opts': dp.opts
                })
        return rs

    def get_disk_usage(self, path='/'):
        '''
        磁盘使用情况
        '''
        du = psutil.disk_usage(path)
        return {
            'total': du.total,
            'used': du.used,
            'free': du.free,
            'percent': du.percent
        }

    def get_disk_partions_and_usage(self):
        '''
        获取磁盘分区和使用情况
        '''
        rs = []
        dps = psutil.disk_partitions(all=False)
        for dp in dps:
            try:
                du = psutil.disk_usage(dp.mountpoint)
            except:
                continue
            rs.append({
                'device': dp.device,
                'mountpoint': dp.mountpoint,
                'fstype': dp.fstype,
                'opts': dp.opts,
                'total': du.total,
                'used': du.used,
                'free': du.free,
                'percent': du.percent
                })
        return rs

    def get_disk_io_counters(self, perdisk=False, nowrap=True):
        '''
        磁盘I/O统计信息

        read_count: numbers of reads
        write_count: numbers of writes
        read_bytes: numbers of bytes read
        write_bytes: numbers of bytes written

        read_time: 从磁盘读取的时间（单位： 毫秒）
        write_time: 写入磁盘的时间（单位： 毫秒）
        busy_time: 花费在实际I/O上的时间（单位： 毫秒）
        read_merged_count: 合并读取的数量
        write_merged_count: 合并写入的数量

        perdisk=True: 返回系统上每个物理盘的相同信息 作为字典（分区名称为key ）
        在一些系统如Linux上，在一个非常繁忙或者长期存在的系统上，内核返回的数字可能会溢出并且被覆盖（从零重新开始），为了防止溢出，如果nowrap=True,会检测和调整这些统计值，将旧值更新到新值，使返回的数字始终保持增加或不变
        '''
        dic = psutil.disk_io_counters(perdisk=perdisk, nowrap=nowrap)
        rs = {
            'read_count': dic.read_count,
            'write_count': dic.write_count,
            'read_bytes': dic.read_bytes,
            'write_bytes': dic.write_bytes,
            'read_time': dic.read_time,
            'write_time': dic.write_time,
        }
        if sys.platform.startswith('linux'):
            rs.update({
                'busy_time': dic.busy_time,
                'read_merged_count': dic.read_merged_count,
                'write_merged_count': dic.write_merged_count,
                #'%util': {}
                })
            # results = os.popen("iostat -ktx 1 2|awk '{print $1,$12}'").read().rstrip('\n').strip()
            # results = results[results.find('%util'):]
            # results = results[results.find('Device: %util'):]
            # results = results.split('\n')[1:]
            # for result in results:
            #     temp = result.split()
            #     rs['%util'].update({
            #         temp[0]: temp[1]
            #         })
        return rs

    def get_disk_io(self):
        rs = {
            'busy_time_percent': {},
            'read_mbps': {},
            'write_mbps': {},
        }
        before = psutil.disk_io_counters(perdisk=True, nowrap=False)
        time.sleep(1)
        after = psutil.disk_io_counters(perdisk=True, nowrap=False)
        for disk_name, after_detail in after.items():
            before_detail = before[disk_name]
            if sys.platform.startswith('linux'):
                rs['busy_time_percent'][disk_name] = '%.2f' % (float(after_detail.busy_time - before_detail.busy_time) / float(1000))
            rs['read_mbps'][disk_name] = '%.2f' % (float(after_detail.read_bytes - before_detail.read_bytes) / float(1024*1024))
            rs['write_mbps'][disk_name] = '%.2f' % (float(after_detail.write_bytes - before_detail.write_bytes) / float(1024*1024))
        return rs

    def get_net_io_counters(self, pernic=False, nowrap=True):
        '''
        系统范围内的网络I/O统计
        @pernic 如果=True 返回系统中安装的每个网络接口的统计信息
        @nowrap 防止内核返回的数字溢出

        bytes_sent: 发送的字节数
        bytes_recv: 接收的字节数
        packets_sent: 发送的数据包数量
        packets_recv: 接收的数据包数量
        errin: 接收时的错误总数
        errout: 发送时的错误总数
        dropin: 丢弃的传入数据包总数
        dropout: 丢弃的传出数据包总数
        '''
        counters = psutil.net_io_counters(pernic=pernic, nowrap=nowrap)
        return {
                'bytes_sent': counters.bytes_sent,
                'bytes_recv': counters.bytes_recv,
                'packets_sent': counters.packets_sent,
                'packets_recv': counters.packets_recv,
                'errin': counters.errin,
                'errout': counters.errout,
                'dropin': counters.dropin,
                'dropout': counters.dropout
            }

    def get_net_io_speed(self):
        '''
        网络I/O速率统计

        bytes_speed: 平均每秒流量 
        packets_speed: 平均每秒包量
        err_speed: 平均每秒错误量
        drop_speed: 平均每秒丢包量
        '''
        counters_1 = psutil.net_io_counters(pernic=False, nowrap=True)
        time.sleep(1)
        counters_2 = psutil.net_io_counters(pernic=False, nowrap=True)
        return {
                'bytes_speed': '%.2f' % (float((counters_2.bytes_sent + counters_2.bytes_recv) - (counters_1.bytes_sent + counters_1.bytes_recv)) / float(1024*1024)), # Mbps
                'bytes_send_speed': '%.2f' % (float(counters_2.bytes_sent - counters_1.bytes_sent) / float(1024*1024)), # Mbps
                'bytes_recv_speed': '%.2f' % (float(counters_2.bytes_recv - counters_1.bytes_recv) / float(1024*1024)), # Mbps
                'packets_speed': (counters_2.packets_sent + counters_2.packets_recv) - (counters_1.packets_sent + counters_1.packets_recv),
                'err_speed': (counters_2.errin + counters_2.errout) - (counters_1.errin + counters_1.errout),
                'drop_speed': (counters_2.dropin + counters_2.dropout) - (counters_1.dropin + counters_1.dropout)
            }

    def get_net_connections(self, kind='inet'):
        '''
        返回系统范围内的socket连接
        @kind str 用与过滤符合以下条件的连接：
            "inet": IPv4 and IPv6
            "inet4": IPv4
            "inet6": IPv6
            "tcp": TCP
            "tcp4": TCP over IPv4
            "tcp6": TCP over IPv6
            "udp": UDP
            "udp4": UDP over IPv4
            "udp6": UDP over IPv6
            "unix": UNIX socket(UDP and TCP)
            "all": 所有
        @return dict
        fd: 套接字文件描述符，如果连接引用当前进程，则可以将其传递给sicket.fromfd()以获取可用的套接字对象;windows中始终为-1
        family: 地址族，可以是AF_INET AF_INET6 AF_UNIX
        laddr: 本地地址(ip, port) 或者AF_UNIX套接字情况下的path
        raddr: 远程地址(ip, port) 或者UNIX套接字情况下的path 如果远端没有连接，则获取到的是一个空的元组或""
        status: TCP连接状态
        pid: 打开套接字的进程pid or None, 在某些平台上(如Linux) 需要root权限
        '''
        rs = []
        connections = psutil.net_connections(kind=kind)
        for connection in connections:
            rs.append({
                'fd': connection.fd,
                'family': connection.family,
                'laddr': connection.laddr,
                'raddr': connection.raddr,
                'status': connection.status,
                'pid': connection.pid
            })
        return rs

    def get_net_if_addrs(self):
        '''
        每个NIC(网络接口卡)关联的地址(网卡绑定的IP 子网掩码 广播地址)
        family: 地址族
        address: 主要的NIC地址
        netmask: 掩码地址(可能为None)
        broadcast: 广播地址(可能为None)
        ptp: 代表"point to point" 点对点接口的目标接口（通常是VPN） broadcast和ptp是互斥的，也许是None
        '''
        rs = {}
        addrs = psutil.net_if_addrs()
        flag = True
        if sys.platform == 'win32':
            flag = False
        for addr, obj in addrs.items():
            temp = []
            for each in obj:
                temp.append({
                    'family': each.family,
                    'address': each.address,
                    'netmask': each.netmask,
                    'broadcast': each.broadcast,
                    'ptp': each.ptp
                })
            if not flag:
                addr = addr.decode('gbk').encode('utf-8')
            rs[addr] = temp
        return rs

    def get_net_if_stats(self):
        '''
        网卡信息 字典 key=NIC names value=统计信息
        isup: 网口是否正常运行
        duplex: 双工通信类型 IC_DUPLEX_FULL NIC_DUPLEX_HALF NIC_DUPLEX_UNKNOWN
        speed: 网口速度(MB), 如果无法确定（如：localhost）将等于0
        mtu: 网口的最大传输单位 (bytes)
        '''
        rs = {}
        stats = psutil.net_if_stats()
        flag = True
        if sys.platform == 'win32':
            flag = False
        for nic, obj in stats.items():
            if not flag:
                nic = nic.decode('gbk').encode('utf-8')
            rs[nic] = {
                'isup': obj.isup,
                'duplex': obj.duplex,
                'speed': obj.speed,
                'mtu': obj.mtu
                }
        return rs


if __name__ == '__main__':
    data = {}
    # 传感器
    if sys.platform.startswith('linux'):
        data['sensors_temperatures']    = psutil.sensors_temperatures(fahrenheit=False) # 硬件温度
        data['sensors_fans']            = psutil.sensors_fans()                         # 硬件风扇速度
        data['sensors_battery']         = psutil.sensors_battery()                      # 电池状态
    
    ic = InfoCollection()
    print '连接用户列表: ', toString(ic.get_users())
    print '系统开机时间: ', toString(ic.get_boot_time())
    print 'CPU核心数: ', toString(ic.get_cpu_count())
    print '获取CPU各指标时间  所有属性的单位都为秒: ', toString(ic.get_cpu_times())
    print 'CPU统计信息: ', toString(ic.get_cpu_stats())
    print 'CPU利用率百分比: ', toString(ic.get_cpu_percent())
    print 'CPU各指标时间的百分比: ', toString(ic.get_cpu_times_percent())
    print '系统内存使用情况  单位是bytes 字节: ', toString(ic.get_virtual_memory())
    print '系统交换内存: ', toString(ic.get_swap_memory())
    print '磁盘分区统计: ', toString(ic.get_disk_partitions())
    print '磁盘使用情况: ', toString(ic.get_disk_usage())
    print '磁盘分区和使用情况: ', toString(ic.get_disk_partions_and_usage())
    print '磁盘I/O 总量统计: ', toString(ic.get_disk_io_counters())
    print '磁盘I/O 速率统计: ', toString(ic.get_disk_io())
    print '网络I/O统计: ', toString(ic.get_net_io_counters())
    print '网络I/O速率统计: ', toString(ic.get_net_io_speed())
    print '返回系统范围内的socket连接: ', toString(ic.get_net_connections())
    print '网卡绑定的IP、子网掩码、广播地址等: ', toString(ic.get_net_if_addrs())
    print '网卡信息： ', toString(ic.get_net_if_stats())
    
    