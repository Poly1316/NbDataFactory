#!/usr/bin/env python
# -*- coding: utf8 -*-
__author__ = 'liyang'


import os

class FindOrigin(object):
    def __init__(self):
        pass


    def cpu_high(self):
        return_message=[]
        top_pid=[]
        pids = os.popen("top -n 3 -d 1 | grep -A 3 -E 'PID|USER' | grep -v PID|head -n 3").read().strip('\n')
        for line in pids.split("\n"):
            top_mess =  line.lstrip('\x1b(B\x1b[m').strip().rstrip('\x1b(B\x1b[m\x1b[39;49m').strip().strip("\n")
            tmp_list=[]
            for a in top_mess.split(" "):
                if a:
                    tmp_list.append(a)
            i = str(tmp_list[0]) + " " + str(tmp_list[8]) + " " + str(tmp_list[9])
            top_pid.append(i)
        for every_pid in top_pid:
            pid = every_pid.split(" ")[0]
            pid_cpu = every_pid.split(" ")[1]
            pid_mem = every_pid.split(" ")[2]
            work_path = os.popen("ls -l  /proc/"+pid+"/ | grep -w cwd |awk -F '-> ' '{print $2}'").read().strip("\n").strip()
            openfiles = os.popen("lsof -p "+pid+ " | wc -l ").read().strip("\n").strip()
            each_jstack = {}
            jstack_info = os.popen("jstack " + str(pid)).read()
            if 'Java' in jstack_info :
                all_threads_jstack = []
                threads = os.popen("top -H -p " +  str(pid) + " -n 3 -d 1 | grep -A 5 -E 'PID|USER'|grep -v PID |awk -F ' ' '{print $1,$9,$10}'").read()
                for i in  threads.split("\n"):
                    if i and '-' not in i:
                        threadid = i.strip("\x1b(B\x1b[m").strip().split(" ")[0]
                        cpu = i.strip("\x1b(B\x1b[m").strip().split(" ")[1]
                        mem = i.strip("\x1b(B\x1b[m").strip().split(" ")[2]
                        threadid_16 = hex(int(threadid))
                        for j in jstack_info.split("\n\n"):
                            if str(threadid_16) in j:
                                message = "thread_id: "+ threadid + ", thread_cpu:" + cpu + ", thread_mem: "+mem+"\n"+ j
                                all_threads_jstack.append(message)
                    each_jstack["message"]= all_threads_jstack
                    each_jstack["pid"] = pid
                    each_jstack["cpu"] = pid_cpu
                    each_jstack["pid_mem"] = pid_mem
                    each_jstack["work_path"] = work_path
                    each_jstack["openfiles"] = openfiles  
            else:
                each_jstack["message"] = "Not java Process ! "
                each_jstack["pid"] = pid
                each_jstack["proc_cpu"] = pid_cpu
                each_jstack["proc_mem"] = pid_mem
                each_jstack["work_path"] = work_path
                each_jstack["openfiles"] = openfiles
            return_message.append(each_jstack)
        return return_message
    



    def diskio_high(self):
        istop_mess = []
        iotop = os.popen("iotop -d 1 -n 1 -b | grep -A 5 TID| head -n 6| grep -v TID").read()
        for line in  iotop.strip('\n').split('\n'):
            istop_mess.append(line.strip())
        return istop_mess




    def mem_high(self):
        memtop_mess = []
        mem_top = os.popen("top  -a -n 2 -d 1|grep -A 3 -E 'PID|USER' | grep -v PID| head -n 3").read().strip('\n')
        for line in mem_top.split('\n'):
            a = line.lstrip("\x1b(B\x1b[m").strip().rstrip("\x1b(B\x1b[m\x1b[39;49").strip()
            tmp_list=[]
            for i in a.split(" "):
                if i:
                    tmp_list.append(i)
            each_mem = {}
            each_mem["pid"]= tmp_list[0]
            each_mem["USER"]= tmp_list[1]
            each_mem["RES"]= tmp_list[5]
            each_mem["CPU"]= tmp_list[8]
            each_mem["MEM"]= tmp_list[9]
            each_mem["COMMAND"]= tmp_list[11]    
            work_path = os.popen("ls -l  /proc/"+each_mem['pid']+"/ | grep -w cwd |awk -F '-> ' '{print $2}'").read().strip("\n").strip()
            each_mem["work_path"] = work_path
            openfiles = os.popen("lsof -p "+each_mem['pid']+ " | wc -l ").read().strip("\n").strip()
            each_mem["openfiles"] = openfiles
            memtop_mess.append(each_mem)
    
        return memtop_mess
